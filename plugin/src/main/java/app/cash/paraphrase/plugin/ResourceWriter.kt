/*
 * Copyright (C) 2023 Cash App
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package app.cash.paraphrase.plugin

import app.cash.paraphrase.plugin.model.MergedResource
import app.cash.paraphrase.plugin.model.MergedResource.Argument
import app.cash.paraphrase.plugin.model.MergedResource.Deprecation
import com.squareup.kotlinpoet.ANY
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.NOTHING
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.buildCodeBlock
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.OffsetDateTime
import java.time.OffsetTime
import java.time.ZoneOffset
import java.time.ZonedDateTime
import kotlin.time.Duration

/**
 * Writes the given tokenized resources to a Kotlin source file.
 */
internal fun writeResources(
  packageName: String,
  mergedResources: List<MergedResource>,
): FileSpec {
  val packageStringsType = ClassName(packageName = packageName, "R", "string")
  val maxVisibility = mergedResources.maxOf { it.visibility }
  val genClassName = "ParaphraseResources"
  val defaultInstanceName = "Android$genClassName"
  return FileSpec.builder(packageName = packageName, fileName = genClassName)
    .addFileComment(
      """
        This code was generated by the Paraphrase Gradle plugin.
        Do not edit this file directly. Instead, edit the string resources in the source file.
      """.trimIndent(),
    )
    .addImport(packageName = packageName, "R")
    .addProperty(
      PropertySpec.builder(
        name = defaultInstanceName,
        type = Types.paraphraseResources(packageName),
      )
        .initializer("$genClassName(%T)", Types.AndroidDateTimeConverter)
        .build(),
    )
    // TODO: Remove deprecated val after a few releases
    .addProperty(
      PropertySpec.builder(
        name = "FormattedResources",
        type = Types.paraphraseResources(packageName),
      )
        .initializer(defaultInstanceName, Types.AndroidDateTimeConverter)
        .addAnnotation(
          AnnotationSpec.builder(
            type = ClassName("kotlin", "Deprecated"),
          )
            .addMember("message = \"\"\"The `FormattedResources` object has been replaced by the `$genClassName` class and the default `$defaultInstanceName` instance. Use the class to allow testing on the JVM, or use the default instance to maintain previous static-like invocation.\"\"\"")
            .addMember("replaceWith = ReplaceWith(\"$defaultInstanceName\")")
            .addMember("level = DeprecationLevel.ERROR")
            .build(),
        )
        .build(),
    )
    .addType(
      TypeSpec.classBuilder(genClassName)
        .primaryConstructor(
          FunSpec.constructorBuilder()
            .addParameter(
              ParameterSpec(
                name = "dateTimeConverter",
                type = Types.DateTimeConverter.parameterizedBy(ANY),
              ),
            )
            .build(),
        )
        .addProperty(
          PropertySpec.builder(
            name = "dateTimeConverter",
            type = Types.DateTimeConverter.parameterizedBy(ANY),
          )
            .addModifiers(KModifier.PRIVATE)
            .initializer("dateTimeConverter")
            .build(),
        )
        .apply {
          mergedResources.forEach { mergedResource ->
            val funSpec = mergedResource.toFunSpec(packageStringsType)
            addFunction(funSpec)

            if (mergedResource.arguments.any { it.type == Long::class }) {
              // Since Ints are used more commonly than Longs, provide an overload to accept Ints
              // for Long arguments:
              addFunction(mergedResource.toIntOverloadFunSpec(funSpec))
            }
          }
        }
        .addModifiers(maxVisibility.toKModifier())
        .build(),
    )
    .build()
}

private fun MergedResource.toFunSpec(packageStringsType: TypeName): FunSpec {
  return FunSpec.builder(name.value)
    .apply { if (description != null) addKdoc(description) }
    .apply { arguments.forEach { addParameter(it.toParameterSpec()) } }
    .returns(Types.FormattedResource)
    .apply {
      if (deprecation is Deprecation.WithMessage) {
        addAnnotation(annotationSpec = deprecatedAnnotationSpec(deprecation))
      }

      if (hasContiguousNumberedTokens) {
        addCode(
          buildCodeBlock {
            add("val arguments = arrayOf(⇥\n")
            for (argument in arguments) {
              addStatement("%L,", argument.toParameterCodeBlock())
            }
            add("⇤)\n")
          },
        )
      } else {
        addStatement("val arguments = %T(%L)", Types.ArrayMap.parameterizedBy(STRING, ANY), arguments.size)

        // The `ArrayMap` into which we place the key-argument pairs uses a backing storage of an
        // array representing a binary tree of the keys ordered by their `hashCode()`. To maximize
        // storage density and minimize runtime complexity, the ideal insertion order sorted, as it
        // results in linear insertion into the array with no shifts. Thankfully `String.hashCode()`
        // is specified by the documentation and thus safe to rely on across the JVM and Android.
        for (argument in arguments.sortedBy { it.key.hashCode() }) {
          addCode("arguments.put(\n⇥")
          addCode("%S,\n", argument.key)
          addCode("%L,\n", argument.toParameterCodeBlock())
          addCode("⇤)\n")
        }
      }
    }
    .addCode(
      buildCodeBlock {
        add("return %T(⇥\n", Types.FormattedResource)
        addStatement("id = %T.%L,", packageStringsType, name.value)
        addStatement("arguments = arguments,")
        add("⇤)\n")
      },
    )
    .addModifiers(visibility.toKModifier())
    .build()
}

private fun deprecatedAnnotationSpec(deprecation: Deprecation.WithMessage): AnnotationSpec {
  return AnnotationSpec.builder(Deprecated::class)
    .addMember("%S", deprecation.message)
    .build()
}

private fun Argument.toParameterSpec(): ParameterSpec =
  ParameterSpec(
    name = name,
    type = when (type) {
      Nothing::class -> NOTHING.copy(nullable = true)
      else -> type.asClassName()
    },
  )

private fun Argument.toParameterCodeBlock(): CodeBlock {
  return when (type) {
    Duration::class -> CodeBlock.of("%L.inWholeSeconds", name)

    // `Nothing` arg must be null, but passing null to the formatter replaces the whole format with
    //  "null". Passing an `Int` allows the formatter to function as expected.
    Nothing::class -> CodeBlock.of("-1")

    LocalDate::class,
    LocalTime::class,
    LocalDateTime::class,
    OffsetTime::class,
    OffsetDateTime::class,
    ZonedDateTime::class,
    ZoneOffset::class,
    -> CodeBlock.of("dateTimeConverter.convertToCalendar(%L)", name)

    else -> CodeBlock.of("%L", name)
  }
}

private fun MergedResource.Visibility.toKModifier(): KModifier {
  return when (this) {
    MergedResource.Visibility.Public -> KModifier.PUBLIC
    MergedResource.Visibility.Private -> KModifier.INTERNAL
  }
}

private fun MergedResource.toIntOverloadFunSpec(overloaded: FunSpec): FunSpec {
  return FunSpec.builder(name.value)
    .apply {
      if (description != null) addKdoc(description)
      addAnnotation(
        annotationSpec = AnnotationSpec.builder(Suppress::class)
          .addMember("%S", "NOTHING_TO_INLINE")
          .build(),
      )
      arguments.forEach { argument ->
        val parameterSpec = if (argument.type == Long::class) {
          ParameterSpec(
            name = argument.name,
            type = Int::class.asClassName(),
          )
        } else {
          argument.toParameterSpec()
        }
        addParameter(parameterSpec)
      }
    }
    .returns(Types.FormattedResource)
    .apply {
      addCode(
        buildCodeBlock {
          add("return %N(⇥\n", overloaded)
          arguments.forEach { argument ->
            val argumentInvocation = if (argument.type == Long::class) {
              "%L.toLong(),\n"
            } else {
              "%L,\n"
            }
            add(argumentInvocation, argument.name)
          }
          add("⇤)\n")
        },
      )
    }
    .addModifiers(visibility.toKModifier(), KModifier.INLINE)
    .build()
}

private object Types {
  val AndroidDateTimeConverter = ClassName("app.cash.paraphrase", "AndroidDateTimeConverter")
  val ArrayMap = ClassName("androidx.collection", "ArrayMap")
  val DateTimeConverter = ClassName("app.cash.paraphrase", "DateTimeConverter")
  val FormattedResource = ClassName("app.cash.paraphrase", "FormattedResource")

  fun paraphraseResources(packageName: String) = ClassName(packageName, "ParaphraseResources")
}
